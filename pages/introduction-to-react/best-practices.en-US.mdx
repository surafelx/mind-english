import { Steps } from "nextra/components";

# Best Practices

React's component-based architecture relies heavily on the management of state and the passing of props between components. Implementing best practices for handling state and props helps maintain a clean, efficient, and scalable React codebase. Here are some recommended practices:

## Handling State

<Steps>

### Use Functional Components with Hooks

Embrace functional components with Hooks, such as useState, for managing state. Hooks provide a concise and readable way to handle state in functional components.

```jsx
import React, { useState } from "react";

const ExampleComponent = () => {
  const [state, setState] = useState(initialValue);

  // Rest of the component logic
};
```

### Avoid Direct State Mutation

Never mutate the state directly. Always use the setState function provided by React to update the state. Direct mutation can lead to unexpected behavior and bugs.

```jsx
// Incorrect
state.property = "new value";

// Correct
setState({ ...state, property: "new value" });
```

### Group Related State:

Group related pieces of state together. This improves code organization and makes it easier to manage the state of a component.

```jsx
const [user, setUser] = useState({ name: "", email: "" });
```

### Use Immer for Complex State Updates

For complex state updates involving nested objects or arrays, consider using the immer library. It allows for more intuitive state mutations.

```jsx
import produce from "immer";

const newState = produce(currentState, (draftState) => {
  // Make modifications to draftState
});
```

</Steps>

## Passing Props

<Steps>

### Avoid Excessive Prop Drilling

Prop drilling (passing props through multiple layers of components) can make the code harder to maintain. Consider using state management libraries like Redux or React Context for global state.

### Use Destructuring for Props

Destructuring props in the function signature enhances code readability and makes it clear which props are being used.

```jsx
// Without destructuring
const MyComponent = (props) => {
  return <div>{props.name}</div>;
};

// With destructuring
const MyComponent = ({ name }) => {
  return <div>{name}</div>;
};
```

### Avoid Mutating Props

Similar to state, never mutate props directly. Treat them as immutable and avoid modifying them within the component.

```jsx
// Incorrect
props.value = "new value";

// Correct
const updatedValue = "new value";
```

### Provide Default Values

Set default values for props when appropriate. This helps prevent unexpected errors when a prop is not passed.

```jsx
const MyComponent = ({ defaultValue = "default" }) => {
  // Component logic
};
```

### PropTypes for Type Checking

Use PropTypes to perform runtime type checking on props. This can catch potential issues early in development.

```jsx
import PropTypes from "prop-types";

MyComponent.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
};

```

By following these best practices, you can create more maintainable and robust React components. Adopting a consistent approach to handling state and props contributes to the overall readability and scalability of your React application.

</Steps>
