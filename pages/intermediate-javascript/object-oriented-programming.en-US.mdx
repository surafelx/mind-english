import { Steps } from "nextra/components";

# Object Oriented JavaScript

Object-oriented programming (OOP) is a powerful paradigm that allows you to organize and structure your code in a more modular and scalable way. In JavaScript, understanding OOP concepts opens up new possibilities for creating robust and maintainable applications. Let's explore key OOP concepts in JavaScript.

### Objects and Classes

In JavaScript, objects are the building blocks of OOP. Objects encapsulate data and behavior into a single entity. The introduction of classes in ECMAScript 6 provides a more structured way to create objects.

**Creating Objects:**

```js
// Using Object Literal
const person = {
  name: "John",
  age: 30,
  sayHello: function () {
    console.log(`Hello, my name is ${this.name}`);
  },
};

// Using Class
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const newPerson = new Person("Jane", 25);
```

### Prototypes and Inheritance

JavaScript uses prototypes for inheritance. Objects can inherit properties and methods from other objects, allowing for code reuse and the creation of hierarchies.

**Inheriting Properties:**

```js
function Animal(name) {
  this.name = name;
}

Animal.prototype.makeSound = function () {
  console.log("Generic animal sound");
};

function Dog(name, breed) {
  Animal.call(this, name);
  this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function () {
  console.log("Woof! Woof!");
};

const myDog = new Dog("Buddy", "Golden Retriever");
```

### Encapsulation and Abstraction

Encapsulation involves bundling data (attributes) and methods that operate on the data into a single unit, while abstraction focuses on hiding the complex implementation details and exposing only what is necessary.

**Encapsulation Example:**

```js
class BankAccount {
  #balance = 0; // Private property

  constructor(owner) {
    this.owner = owner;
  }

  deposit(amount) {
    this.#balance += amount;
  }

  withdraw(amount) {
    if (amount <= this.#balance) {
      this.#balance -= amount;
    } else {
      console.log("Insufficient funds");
    }
  }

  getBalance() {
    return this.#balance;
  }
}

const myAccount = new BankAccount("John Doe");
myAccount.deposit(1000);
myAccount.withdraw(500);
```

### Polymorphism:

Polymorphism allows objects of different types to be treated as objects of a common type. This enhances code flexibility and readability.

**Polymorphism Example:**

```js
class Shape {
  area() {
    console.log("Calculating area");
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  area() {
    console.log(`Circle Area: ${Math.PI * this.radius ** 2}`);
  }
}

class Square extends Shape {
  constructor(side) {
    super();
    this.side = side;
  }

  area() {
    console.log(`Square Area: ${this.side ** 2}`);
  }
}

const circle = new Circle(5);
const square = new Square(4);

const shapes = [circle, square];
shapes.forEach((shape) => shape.area());
```

## Benefits of Object-Oriented JavaScript:

<Steps>

### **Modularity**

OOP promotes code modularity, making it easier to maintain and understand.

### **Reusability**

Objects and classes facilitate code reuse, reducing redundancy.

### **Scalability**

</Steps>
OOP supports the development of scalable and organized codebases.

Mastering object-oriented JavaScript empowers you to build complex and scalable applications, laying a solid foundation for advanced web development.
