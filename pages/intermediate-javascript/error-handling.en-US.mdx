# Error Handling

Error handling is a critical aspect of JavaScript development, ensuring that applications respond gracefully to unexpected situations. In this guide, we'll explore various techniques and best practices for handling errors effectively.

## Understanding Errors in JavaScript:

Error Types: JavaScript has built-in error types, such as SyntaxError, ReferenceError, TypeError, and more, each indicating a specific kind of problem.
Stack Trace: When an error occurs, the stack trace provides information about the sequence of function calls that led to the error.

```js
// Example of a ReferenceError
try {
  // Attempting to use an undefined variable
  console.log(undefinedVariable);
} catch (error) {
  console.error("Error:", error.message);
}
```

## Using try-catch Blocks:

try Block: The try block contains the code that might throw an exception.
catch Block: The catch block is executed when an exception occurs, allowing you to handle the error.

```js
try {
  // Code that might throw an error
} catch (error) {
  // Handle the error
}
```

## Throwing Custom Errors:

throw Statement: Developers can use the throw statement to create and throw custom errors, providing more context about the issue.

```js
function divideNumbers(a, b) {
  if (b === 0) {
    throw new Error("Cannot divide by zero");
  }
  return a / b;
}
```

## Asynchronous Error Handling:

Promises: When working with asynchronous code using Promises, the catch method is used to handle errors.
Async/Await: With async/await syntax, errors can be handled using try-catch blocks in a more synchronous style.

```js
// Example with Promises
fetch("https://api.example.com/data")
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));

// Example with Async/Await
async function fetchData() {
  try {
    const response = await fetch("https://api.example.com/data");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Error:", error);
  }
}
```

## Handling Asynchronous Errors in Promises:

Promise.allSettled: Use Promise.allSettled to handle errors when working with multiple Promises, ensuring all Promises are settled (fulfilled or rejected).

```js
const promises = [fetchData1(), fetchData2(), fetchData3()];

Promise.allSettled(promises).then((results) => {
  results.forEach((result) => {
    if (result.status === "rejected") {
      console.error("Error:", result.reason);
    }
  });
});
```

## Global Error Handling:

window.onerror: The window.onerror event handler can be used for global error handling, capturing unhandled errors.

```js
window.onerror = function (message, source, lineno, colno, error) {
  console.error("Global Error:", message, source, lineno, colno, error);
};
```

By mastering error handling techniques in JavaScript, developers can create robust and resilient applications that gracefully handle unexpected situations, providing a better user experience and simplifying debugging efforts.
