import { Steps } from "nextra/components";

# State Management

State management is a crucial aspect of building dynamic and responsive React applications. As projects grow in complexity, advanced state management techniques become essential for maintaining clean and efficient code. In this article, we'll explore advanced state management concepts in React.

### State Hook

Introduced in React 16.8, the State Hook (useState) allows functional components to manage state without using class components. It returns a stateful value and a function to update it. This hook is fundamental for handling state in functional components.

```jsx
import React, { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

### Context API

The Context API provides a way to pass data through the component tree without manually passing props at every level. It's particularly useful for global state management. Create a context and use Provider and Consumer components to share values.

```jsx
import React, { createContext, useContext } from "react";

const ThemeContext = createContext();

const ThemedComponent = () => {
  const theme = useContext(ThemeContext);

  return <p style={{ color: theme }}>Themed Content</p>;
};
```

### Reducers

Reducers are functions responsible for handling state transitions in response to dispatched actions. They are often used with the useReducer Hook for managing complex state logic.

```jsx
import React, { useReducer } from "react";

const initialState = { count: 0 };

const reducer = (state, action) => {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    default:
      return state;
  }
};

const Counter = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>Increment</button>
    </div>
  );
};
```

### Custom Hooks

Custom Hooks are a way to reuse stateful logic across different
components. By convention, their names should start with "use." You can create custom
Hooks to encapsulate complex logic and share it across components.

```jsx
import { useState, useEffect } from "react";

const useFetchData = (url) => {
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch(url);
      const result = await response.json();
      setData(result);
    };

    fetchData();
  }, [url]);
  return data;
};
```

### Immer for Immutable State

Immer is a library that simplifies the process of working with immutable state. It allows you to write code that looks like you're modifying the state directly, but it produces a new immutable state behind the scenes.

```jsx
import produce from "immer";

const state = { count: 0 };

const nextState = produce(state, (draftState) => {
  draftState.count += 1;
});
```

These advanced state management techniques empower developers to handle more complex scenarios in React applications. Whether using Hooks, Context API, Reducers, Custom Hooks, or Immer, choosing the right approach depends on the specific requirements of your project. Understanding these concepts will enhance your ability to build scalable and maintainable React applications.
